# Firegen — wildfire mapping and drone-swarm simulator/visualizer

Firegen is a continuation of our Dalhousie Engineering Competition (DEC) project that qualified for the Atlantic Engineering Competition (AEC). After the competition deadline, the project was so close to being fully functional that we decided to finish it. This repo contains the completed, working version.

- Original DEC submission: FirefighterDEC (on GitHub)
- Authors of the original: Jack C., Megan Neville, Ryan LeBlanc, and Liam Legge
- This continuation: translated the core solver/simulator from Python to C++, converted the provided C stub to C++, and integrated the visualization to use real simulator output (instead of manually seeded demo data used during the competition)


## What this project does

At a high level, Firegen simulates a 550×100 grid world representing a region under wildfire conditions, with:

- Fire severity per tile (0–9), wind speed and direction, citizens, and firefighters
- Six “base stations” positioned across the width of the map; one drone starts at each base
- A simple environment model that spreads fire downwind and applies firefighter mitigation
- A drone policy that scouts, targets severe fires, manages water refills, and logs what it sees

Each round, the simulator emits:

- `map.txt` — the full “truth” map for the latest round and a header with the round number
- `maps/map_roundNNN.txt` — archived full maps for each round
- `vision/vision_roundNNN.txt` — what drones saw in their 3×3 scan windows that round
- `paths/paths_roundNNN_droneK.csv` — per-drone paths for the round (with step, x, y columns)

The Python visualizer (`fire_viz.py`) renders the evolving fire severity along with citizens, firefighters, and the drone positions/paths. In the competition we could only show seeded demo data; in this repo the visualizer is wired to live outputs generated by the C++ program.


## Repository layout

- `src/` — C++ sources for the simulator and policy
	- `Grid.hpp/.cpp` — grid types, I/O, and a compact tile encoding
	- `FireGen.hpp/.cpp` — environment initialization and fire spread dynamics
	- `Drone.hpp/.cpp` — drone behavior: scouting, targeting, refilling, path/vision logging
	- `Rescue.hpp/.cpp` — simple citizen evacuation heuristic (applied inside the environment)
	- `Predict.hpp/.cpp` — lightweight optional prediction heuristic (not required to run)
	- `Simulation.hpp/.cpp` — main per-round loop and artifact writers (maps, vision, paths)
	- `main.cpp` — small CLI that configures and runs the simulation
- `fire_viz.py` — matplotlib-based visualizer for outputs, with a demo-data mode
- `build.ps1` — PowerShell helper that compiles on Windows using MSVC, MinGW, or Clang
- `CMakeLists.txt` — alternative build via CMake
- `maps/`, `paths/`, `vision/` — sample outputs and/or previously generated runs


## Background and credits

This project began as a Dalhousie Engineering Competition (DEC) challenge. Our team qualified for the Atlantic Engineering Competition (AEC). The original entry (FirefighterDEC) was a collaboration between:

- Jack C.
- Megan Neville
- Ryan LeBlanc
- Liam Legge

Post-competition, we finished the implementation:

- Ported the core engine from Python to modern C++ (C++20)
- Converted the provided C file to C++ and integrated all components
- Kept the visualization approach, but hooked it up to real simulation data


## How it works (short version)

- Grid: 550 columns × 100 rows. Each tile holds fire severity (0–9), wind (0–3), wind dir (0–3: N/E/S/W), and presence of citizens/firefighters.
- Fire spread: severity ≥4 spreads one tile downwind each round; if the target is already burning, it bumps severity toward 9; otherwise the target becomes roughly half the source severity.
- Firefighters: reduce severity on their tile and its 4-neighbors each round.
- Drones: each base station spawns one drone. A drone either scouts, goes to a severe fire, extinguishes, or returns to base to refill. Drones log a 3×3 “vision” around their position each round and write their round path.
- Outputs: full map snapshot per round, per-round sparse “vision”, and per-drone CSV paths.
- Visualization: overlays predicted vs. historical fire severity with citizens, firefighters, and drone markers. In “from outputs” mode it consumes the simulator’s `vision/`, `paths/`, and optional `maps/` archives.


## Build (Windows, PowerShell)

You have two easy options on Windows.

1) PowerShell helper (auto-detects compiler)

```powershell
# From repo root
./build.ps1

# Clean objects/executable
./build.ps1 -Clean
```

2) CMake (Visual Studio, Ninja, or NMake)

```powershell
# From repo root
cmake -S . -B build
cmake --build build --config Release
```

Either approach will produce `firedrones.exe` in the repo root (PowerShell path) or under `build/` (CMake, depending on generator). If you’re using MSVC, it’s easiest to run from “Developer PowerShell for VS” so `cl` is on PATH.


## Run the simulator

Command-line options are parsed in `src/main.cpp`.

```
firedrones [options]
	--rounds N          Number of rounds (default 10)
	--map PATH          Path to map.txt (default map.txt)
	--vision DIR        Directory for vision files (default vision)
	--paths DIR         Directory for path files (default paths)
	--seed S            RNG seed for generator (default 1)
	--emit-predicted    Also run Predict::bumpDownwind each round (optional)
```

Examples (PowerShell):

```powershell
# Quick 20-round run with defaults; artifacts land in map.txt, vision/, paths/, maps/
./firedrones.exe --rounds 20

# Custom output locations and seed
./firedrones.exe --rounds 50 --map out\map.txt --vision out\vision --paths out\paths --seed 42

# With optional heuristic prediction enabled
./firedrones.exe --rounds 30 --emit-predicted
```

What gets written each round:

- `map.txt`: full “truth” grid with a header line containing the round number
- `maps/map_roundNNN.txt`: archived full maps by round
- `vision/vision_roundNNN.txt`: 3×3 FoV (per drone), de-duplicated across drones
- `paths/paths_roundNNN_droneK.csv`: a drone K CSV with columns `drone_id,step,x,y`


## Visualize outputs (Python)

Requirements: Python 3.9+ and the following packages: `numpy`, `matplotlib`, `pillow`.

```powershell
# Optional venv
python -m venv .venv; .\.venv\Scripts\Activate.ps1
pip install -r requirements.txt
```

Use the visualizer in “from outputs” mode to build an animation from simulator artifacts. By default, the script now writes to the `GIFs/` folder and will auto-create the parent directory for any `--outfile` path you provide.

```powershell
# Basic: consume vision/ and paths/, ignore archived full maps (outputs to GIFs/)
python fire_viz.py --from-outputs --maps-dir maps --bg basemap.jpg --vision-only --outfile GIFs/POV.gif

# Full map view (outputs to GIFs/)
python fire_viz.py --from-outputs --maps-dir maps --bg basemap.jpg --outfile GIFs/fire_viz.gif
```

Notes:

- The visualizer auto-discovers rounds by scanning `vision/vision_roundNNN.txt` files.
- If `--vision-only` is used, it visualizes only drone FoV (sparse). Otherwise it will use `maps/map_roundNNN.txt` when available.
- Drones are rendered with “X” markers, citizens as triangles, firefighters as squares. Severity 0 tiles are gray; unmapped tiles are transparent.


## Data model and file formats

Dimensions: `WIDTH=550`, `HEIGHT=100` (defined in `src/Grid.hpp`).

- Tile fields: `fire_sev (0–9)`, `windspeed (0–9)`, `winddir (0–3: N/E/S/W)`, `citizen (0/1)`, `firefighter (0/1)`.
- Encoded line: `AAABBCDEFG` where
	- `AAA` = x (000–549)
	- `BB`  = y (00–99)
	- `C`   = fire severity
	- `D`   = wind speed
	- `E`   = wind dir (0:N,1:E,2:S,3:W)
	- `F`   = citizen flag
	- `G`   = firefighter flag

Files:

- `map.txt`: first line is the current round number; subsequent lines are encoded tiles for the entire grid.
- `maps/map_roundNNN.txt`: same as `map.txt` but archived per round.
- `vision/vision_roundNNN.txt`: a subset of encoded lines covering every tile within each drone’s 3×3 scan window for that round. Lines are de-duplicated across drones.
- `paths/paths_roundNNN_droneK.csv`: CSV per drone K with columns `drone_id,step,x,y` showing that drone’s path within the round.


## Example workflow

```powershell
# 1) Build
./build.ps1

# 2) Simulate 60 rounds
./firedrones.exe --rounds 60 --seed 7

# 3) Visualize results into an animated GIF (saved to GIFs/)
python fire_viz.py --from-outputs --maps-dir maps --bg basemap.jpg --outfile GIFs/fire_viz.gif
```


## Design notes

- Six base stations are hard-coded to approximate regional hubs; one drone spawns at each.
- Drone policy balances scouting with targeted response to severe fires (≥4). Water is finite; drones return to base to refill when low.
- Fire spread and firefighter mitigation are deliberately simple and deterministic given a seed, to support quick iteration and visualization.
- `Predict::bumpDownwind` is an optional, conservative overlay that hints at likely downwind intensification; it’s disabled by default and can be enabled with `--emit-predicted`.


## Acknowledgements

Thanks to the Dalhousie Engineering Competition organizers and the AEC. Original collaboration by Jack C., Megan Neville, Ryan LeBlanc, and Liam Legge. This continuation completed the near-finished work by porting to C++ and wiring the visualizer to real outputs.


